{"version":3,"sources":["webpack:///./node_modules/core-js/library/modules/_object-to-array.js","webpack:///./src/views/Network.vue?92a6","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/entries.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/create.js","webpack:///./node_modules/core-js/modules/es6.function.name.js","webpack:///./node_modules/core-js/library/modules/es6.object.create.js","webpack:///./node_modules/core-js/library/modules/es7.object.entries.js","webpack:///./node_modules/core-js/library/fn/json/stringify.js","webpack:///./node_modules/core-js/modules/web.dom.iterable.js","webpack:///./node_modules/core-js/library/fn/object/entries.js","webpack:///./src/views/Network.vue?e20d","webpack:///./src/plugins/sigma.plugins.tooltips.js","webpack:///src/views/Network.vue","webpack:///./src/views/Network.vue?757b","webpack:///./src/views/Network.vue?1790","webpack:///./node_modules/core-js/library/fn/object/create.js","webpack:///./node_modules/sigma/build/sigma.require.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/json/stringify.js"],"names":["getKeys","__webpack_require__","toIObject","isEnum","f","module","exports","isEntries","it","key","O","keys","length","i","result","call","push","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Network_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Network_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default","n","dP","FProto","Function","prototype","nameRE","NAME","configurable","get","this","match","e","$export","S","create","$entries","entries","core","$JSON","JSON","stringify","apply","arguments","$iterators","redefine","global","hide","Iterators","wks","ITERATOR","TO_STRING_TAG","ArrayValues","Array","DOMIterables","CSSRuleList","CSSStyleDeclaration","CSSValueList","ClientRectList","DOMRectList","DOMStringList","DOMTokenList","DataTransferItemList","FileList","HTMLAllCollection","HTMLCollection","HTMLFormElement","HTMLSelectElement","MediaList","MimeTypeArray","NamedNodeMap","NodeList","PaintRequestList","Plugin","PluginArray","SVGLengthList","SVGNumberList","SVGPathSegList","SVGPointList","SVGStringList","SVGTransformList","SourceBufferList","StyleSheetList","TextTrackCueList","TextTrackList","TouchList","collections","explicit","Collection","proto","Object","render","_vm","_h","$createElement","_c","_self","attrs","id","staticClass","bottom","scopedSlots","_u","fn","ref","on","_g","click","$event","saveAs","_v","doImport","purge","value","error","msg","type","_s","fluid","staticRenderFns","sigma","utils","pkg","settings","stage","show","cssClass","position","autoadjust","delay","template","renderer","node","edge","doubleClickDelay","Tooltips","s","options","_tooltip","_timeoutHandle","self","so","extend","no","eo","_doubleClick","contextmenuListener","event","preventDefault","remove","parentNode","removeChild","cancel","clearTimeout","classes","dispatcher","bind","plugins","killTooltips","open","o","x","y","document","createElement","tooltipRenderer","k","clone","create_default","graph","innerHTML","appendChild","className","style","containerRect","container","getBoundingClientRect","left","top","setTimeout","bodyRect","body","tooltipRect","offsetTop","offsetBottom","offsetLeft","offsetRight","right","width","height","close","kill","unbindEvents","unbind","removeEventListener","undefined","clientX","data","captor","clientY","dispatchEvent","p","nodes","edges","addEventListener","_instance","tooltips","window","Networkvue_type_script_lang_js_","name","verbose","resultData","minEdgeSize","maxEdgeSize","minNodeSize","maxNodeSize","enableEdgeHovering","labelThreshold","defaultEdgeColor","defaultEdgeType","enableHovering","edgeColor","edgeHoverColor","defaultEdgeHoverColor","edgeHoverSizeRatio","edgeHoverExtremities","fixedScaling","zoomMin","zoomMax","tooltipSetup","inputDialog","visible","computed","$store","state","methods","obj","v1","v2","console","log","makeTableHTML","entries_default","stringify_default","myArray","j","firstCharAsCaps","string","charAt","toUpperCase","slice","trim","setup","_this","thisCtx","WebServices","getNodes","then","map","label","color","size","forEach","a","Math","cos","PI","sin","getEdges","from","to","source","target","renderGraph","dispatch","$refs","sigmaContainer","sigma_require_default","renderers","read","refresh","action","_action","err","getDownloadLink","url","link","getElementById","setAttribute","href","catch","input","onchange","file","files","response","mounted","views_Networkvue_type_script_lang_js_","component","componentNormalizer","__webpack_exports__","installComponents_default","VAlert","VBtn","VCard","VContainer","VIcon","VSpacer","VGrid","VToolbar","VTooltip","$Object","P","D","__instances","conf","l","_conf","HTMLElement","toString","defineProperty","cameras","_handler","addRenderer","middlewares","addCamera","camera","quadtree","quad","edgequad","edgequadtree","renderCamera","isAnimated","renderersPerCamera","killCamera","v","killRenderer","cameraFrames","def","indexOf","splice","c","bounds","prefix","rescale","readPrefix","copy","skipIndexation","getBoundaries","index","minX","minY","maxX","maxY","process","force","requestAnimationFrame","hasOwnProperty","instances","version","conrad","Error","_lastFrameTime","_isRunning","_jobs","_runningJobs","_sortedByPriorityJobs","_waitingJobs","_doneJobs","_noStart","_parameters","frameDuration","history","_handlers","_bind","events","handler","i_end","eArray","isArray","split","_unbind","j_end","_dispatch","eventName","_executeFirstJob","test","pushed","time","__dateNow","job","shift","done","currentTime","weightTime","weight","averageTime","count","_activateJob","status","startTime","__clone","_loop","deadJob","after","_killJob","_addJob","__extend","_hasJob","found","end","_killAll","jobs","_settings","a1","a2","_getIsRunning","_clearHistory","_getStats","stats","pattern","isPatternString","concat","__objectValues","RegExp","res","item","Date","now","getTime","hasJob","addJob","killJob","killAll","getStats","isRunning","clearHistory","_root","dateNow","pkgName","reduce","context","objName","floatColorCache","floatColor","val","original","r","g","b","parseInt","zoomTo","ratio","animation","newRatio","coordinates","max","min","duration","misc","easing","goTo","onComplete","getQuadraticControlPoint","x1","y1","x2","y2","getPointOnQuadraticCurve","t","xi","yi","pow","getPointOnBezierCurve","cx","cy","dx","dy","B0_t","B1_t","B2_t","B3_t","getSelfLoopControlPoints","getDistance","x0","y0","sqrt","getCircleIntersection","r0","r1","d","h","rx","ry","abs","xi_prime","yi_prime","isPointOnSegment","epsilon","crossProduct","nCrossProduct","isPointOnQuadraticCurve","cpx","cpy","dP1P2","old_dt","dP1","dP2","rThreshold","pt","dt","isPointOnBezierCurve","cpx1","cpy1","cpx2","cpy2","dP1CP1","getX","offsetX","layerX","getY","offsetY","layerY","getPixelRatio","screen","deviceXDPI","logicalXDPI","systemXDPI","devicePixelRatio","getWidth","w","ownerSVGElement","baseVal","getCenter","namespaceURI","getHeight","mouseCoords","ctrlKey","metaKey","altKey","shiftKey","getDelta","wheelDelta","detail","getOffset","dom","offsetParent","doubleClick","callback","handlers","clicks","_doubleClickHandler","doubleClickTimeout","unbindDoubleClick","pop","easings","linearNone","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","loadShader","gl","shaderSource","shaderType","compiled","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadProgram","shaders","attribs","loc","linked","program","createProgram","attachShader","bindAttribLocation","locations","opt_attribs","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","matrices","translation","rotation","angle","m2","scale","multiply","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","lastTime","vendors","cancelAnimationFrame","element","currTime","timeToCall","oThis","TypeError","fNOP","fBound","aArgs","fToBind","immutable","classPrefix","defaultNodeType","defaultLabelColor","defaultNodeColor","defaultLabelSize","minArrowSize","font","fontStyle","labelColor","labelSize","labelSizeRatio","webglOversamplingRatio","borderSize","defaultNodeBorderColor","hoverFont","singleHover","hoverFontStyle","labelHoverShadow","labelHoverShadowColor","nodeHoverColor","defaultNodeHoverColor","labelHoverBGColor","defaultHoverLabelBGColor","labelHoverColor","defaultLabelHoverColor","drawEdges","drawNodes","drawLabels","drawEdgeLabels","batchEdgesDrawing","hideEdgesOnMove","canvasEdgesBatchSize","webglEdgesBatchSize","scalingMode","sideMargin","touchEnabled","mouseEnabled","mouseWheelEnabled","doubleClickEnabled","eventsEnabled","zoomingRatio","doubleClickZoomingRatio","mouseZoomDuration","doubleClickZoomDuration","mouseInertiaDuration","mouseInertiaRatio","touchInertiaDuration","touchInertiaRatio","doubleTapTimeout","dragTimeout","autoResize","autoRescale","enableCamera","edgeHoverPrecision","rescaleIgnoreSize","skipErrors","nodesPowRatio","edgesPowRatio","animationsTime","m","getEvent","one","args","datas","embedObjects","_methods","_indexes","_initBindings","_methodBindings","_methodBeforeBindings","_defaultSettings","_defaultSettingsFunction","nodesArray","edgesArray","nodesIndex","edgesIndex","inNeighborsIndex","outNeighborsIndex","allNeighborsIndex","inNeighborsCount","outNeighborsCount","allNeighborsCount","__bindGraphMethod","methodName","scope","__emptyObject","addMethod","hasMethod","attach","before","bindings","attachBefore","addIndex","validNode","enumerable","validEdge","dropEdge","addNode","addEdge","which","in","out","embedObject","isNaN","applyView","write","relCos","relSin","nodeRatio","edgeRatio","xOffset","yOffset","graphPosition","vector","X","Y","cameraPosition","getMatrix","matrix","getRectangle","widthVect","heightVect","centerVect","marginX","marginY","_geom","pointToSquare","isAxisAligned","axisAlignedTopPoints","lowerLeftCoor","lowerRightCoor","llc","rectangleCorners","lrc","splitSquare","axis","c1","c2","projection","axisCollision","sc1","sc2","ci","p1","p2","maxc1","maxc2","minc1","minc2","collision","col","_quadIndex","point","quadBounds","xmp","ymp","_quadIndexes","rectangle","quadCorners","indexes","_quadCollision","corners","_quadSubdivide","next","level","subw","round","subh","qx","qy","_quadTree","maxElements","maxLevel","_quadInsert","el","sizedPoint","elements","_quadRetrievePoint","_quadRetrieveArea","rectData","collisionFunc","els","_tree","_cache","query","params","area","rect","serialized","lineToSquare","quadraticCurveToSquare","cp","selfLoopToSquare","_enabled","captors","mouse","_startCameraX","_startCameraY","_lastCameraX","_lastCameraY","_startMouseX","_startMouseY","_isMouseDown","_isMoving","_hasDragged","_downStartTime","_movingTimeoutId","_target","_camera","_moveHandler","pos","isMoving","returnValue","stopPropagation","_upHandler","_downHandler","_outHandler","_clickHandler","isDragging","_wheelHandler","touch","_startCameraAngle","_startCameraRatio","_startTouchX0","_startTouchY0","_startTouchX1","_startTouchY1","_startTouchAngle","_startTouchDistance","_touchMode","_doubleTap","_downTouches","offset","pageX","pageY","_handleStart","pos0","pos1","touches","atan2","_handleLeave","inertiaRatio","_handleMove","diff","start","dAngle","dRatio","newStageX","newStageY","newStageRatio","newStageAngle","_doubleTapHandler","canvas","contexts","domElements","nodesOnScreen","edgesOnScreen","conradId","initDOM","scene","labels","hover","bindEvents","drawHovers","resize","batchSize","tempGCO","embedSettings","clear","hidden","globalCompositeOperation","tag","toLowerCase","getContext","oldWidth","oldHeight","pixelRatio","offsetWidth","offsetHeight","tagName","clearRect","webgl","nodeFloatArrays","edgeFloatArrays","edgeIndicesArrays","array","Float32Array","POINTS","ATTRIBUTES","computeIndices","nodesGl","edgesGl","arr","indices","edgePrograms","initProgram","useProgram","scalingRatio","indicesData","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodePrograms","preserveDrawingBuffer","viewport","COLOR_BUFFER_BIT","svg","groups","hovers","measurementCanvas","freeStyle","bindDOMEvents","bindHovers","subrenderers","forceLabels","hideDOMElements","update","createElementNS","setAttributeNS","hoveredNode","overNode","outNode","WebGLRenderingContext","buffer","positionLocation","getAttribLocation","sizeLocation","colorLocation","angleLocation","resolutionLocation","getUniformLocation","matrixLocation","ratioLocation","scaleLocation","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","uniform2f","uniform1f","uniformMatrix3fv","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawArrays","TRIANGLES","vertexShader","fragmentShader","join","VERTEX_SHADER","FRAGMENT_SHADER","fast","positionLocation1","positionLocation2","thicknessLocation","minusLocation","matrixHalfPiLocation","matrixHalfPiMinusLocation","STATIC_DRAW","uniformMatrix2fv","lineWidth","LINES","arrow","targetSize","targetSizeLocation","delayLocation","headLocation","headPositionLocation","nodeRatioLocation","arrowHeadLocation","fontSize","fillStyle","fillText","beginPath","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","measureText","moveTo","arcTo","lineTo","closePath","fill","arc","nodeRenderer","strokeStyle","stroke","tSize","sX","sY","tX","tY","aSize","aX","aY","vX","vY","edgehovers","hover_color","curve","sSize","bezierCurveTo","quadraticCurveTo","curvedArrow","extremities","display","circle","line","path","text","fontColor","textContent","nodeCircle","group","writePrefix","margin","sizeMax","weightMax","rescaleSettings","validSettings","nodePosition","nodeSize","edgeSize","np","ns","es","doEdges","Infinity","_getID","anim","initialVal","coef","running","onNewFrame","frameId","filter","has","mX","mY","inserted","selected","modifiedX","modifiedY","isCanvas","maxEpsilon","nodeIndex","insertEdge","bindCaptor","overNodes","overEdges","onClick","onDoubleClick","onRightClick","onOut","le","outNodes","outEdges","onMove","newOutNodes","newOverNodes","currentOverNodes","newOutEdges","newOverEdges","currentOverEdges","Element","domElement","attr","attrName","getAttributeNS","class","isNode","isEdge","isHover","onOver","toElement","fromElement","originalTarget","hoveredNodes","hoveredEdges","draw","hoveredEdge","nodeRenderers","edgeRenderers","extremitiesRenderers"],"mappings":"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","file":"js/chunk-1e5155eb.e00b4ee5.js","sourcesContent":["var getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Network.vue?vue&type=style&index=0&lang=css&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Network.vue?vue&type=style&index=0&lang=css&\"","module.exports = require(\"core-js/library/fn/object/entries\");","module.exports = require(\"core-js/library/fn/object/create\");","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","var $export = require('./_export');\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: require('./_object-create') });\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n","var core = require('../../modules/_core');\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","require('../../modules/es7.object.entries');\nmodule.exports = require('../../modules/_core').Object.entries;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"sticky\"}},[_c('v-toolbar',{staticClass:\"my-toolbar\"},[_c('v-tooltip',{attrs:{\"bottom\":\"\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('v-btn',_vm._g({on:{\"click\":function($event){return _vm.saveAs('export')}}},on),[_c('v-icon',[_vm._v(\"cloud\")])],1)]}}])},[_c('span',[_vm._v(\"Export host configuration of local node \")])]),_c('v-tooltip',{attrs:{\"bottom\":\"\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('v-btn',_vm._g({on:{\"click\":function($event){return _vm.saveAs('export-all')}}},on),[_c('v-icon',[_vm._v(\"cloud_circle\")])],1)]}}])},[_c('span',[_vm._v(\"Export all host configuration files\")])]),_c('v-tooltip',{attrs:{\"bottom\":\"\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('v-btn',_vm._g({on:{\"click\":function($event){return _vm.doImport()}}},on),[_c('v-icon',[_vm._v(\"cloud_download\")])],1)]}}])},[_c('span',[_vm._v(\"Import host configuration file(s)\")])]),_c('v-tooltip',{attrs:{\"bottom\":\"\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('v-btn',_vm._g({on:{\"click\":function($event){return _vm.purge()}}},on),[_c('v-icon',[_vm._v(\"delete_outline\")])],1)]}}])},[_c('span',[_vm._v(\"Purge unreachable nodes\")])]),_c('v-spacer')],1),_c('v-alert',{attrs:{\"value\":_vm.error.msg!=null,\"type\":_vm.error.type}},[_vm._v(_vm._s(_vm.error.msg))]),_c('v-container',{attrs:{\"fluid\":\"\"}},[_c('v-card',[_c('v-container',{attrs:{\"fluid\":\"\"}},[_c('div',{ref:\"sigmaContainer\",attrs:{\"id\":\"sigmaContainer\"}})])],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import sigma from 'sigma'\n\n/**\n * This plugin provides a method to display a tooltip at a specific event, e.g.\n * to display some node properties on node hover. Check the\n * sigma.plugins.tooltip function doc or the examples/tooltip.html code sample\n * to know more.\n */\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.plugins');\n\n  /**\n   * Sigma tooltip\n   * =============================\n   *\n   * @author Sébastien Heymann <seb@linkurio.us> (Linkurious)\n   * @version 0.3\n   */\n\n  var settings = {\n    stage: {\n      show: 'rightClickStage',\n      hide: 'clickStage',\n      cssClass: 'sigma-tooltip',\n      position: '',       // top | bottom | left | right\n      autoadjust: false,\n      delay: 0,\n      template: '',       // HTML string\n      renderer: null      // function\n    },\n    node: {\n      show: 'clickNode',\n      hide: 'clickStage',\n      cssClass: 'sigma-tooltip',\n      position: '',       // top | bottom | left | right\n      autoadjust: false,\n      delay: 0,\n      template: '',       // HTML string\n      renderer: null      // function\n    },\n    edge: {\n      show: 'clickEdge',\n      hide: 'clickStage',\n      cssClass: 'sigma-tooltip',\n      position: '',       // top | bottom | left | right\n      autoadjust: false,\n      delay: 0,\n      template: '',       // HTML string\n      renderer: null      // function\n    },\n    doubleClickDelay: 800\n  };\n\n\n  /**\n   * This function will display a tooltip when a sigma event is fired. It will\n   * basically create a DOM element, fill it with the template or the result of\n   * the renderer function, set its position and CSS class, and insert the\n   * element as a child of the sigma container. Only one tooltip may exist.\n   *\n   * Recognized parameters of options:\n   * *********************************\n   * Enable node tooltips by adding the \"node\" key to the options object.\n   * Enable edge tooltips by adding the \"edge\" key to the options object.\n   * Each value must be an object. Here is the exhaustive list of every\n   * accepted parameters in these objects:\n   *\n   *   {?string}   show       The event that triggers the tooltip. Default\n   *                          values: \"clickNode\", \"clickEdge\". Other suggested\n   *                          values: \"overNode\", \"doubleClickNode\",\n   *                          \"rightClickNode\", \"overEdge\", \"doubleClickEdge\",\n   *                          \"rightClickEdge\", \"doubleClickNode\",\n   *                          \"rightClickNode\".\n   *   {?string}   hide       The event that hides the tooltip. Default value:\n   *                          \"clickStage\". Other suggested values: \"outNode\",\n   *                          \"outEdge\".\n   *   {?string}   template   The HTML template. It is directly inserted inside\n   *                          a div element unless a renderer is specified.\n   *   {?function} renderer   This function may process the template or be used\n   *                          independently. It should return an HTML string or\n   *                          a DOM element. It is executed at runtime. Its\n   *                          context is sigma.graph.\n   *   {?string}   cssClass   The CSS class attached to the top div element.\n   *                          Default value: \"sigma-tooltip\".\n   *   {?string}   position   The position of the tooltip regarding the mouse.\n   *                          If it is not specified, the tooltip top-left\n   *                          corner is positionned at the mouse position.\n   *                          Available values: \"top\", \"bottom\", \"left\",\n   *                          \"right\".\n   *   {?number}   delay      The delay in miliseconds before displaying the\n   *                          tooltip after the show event is triggered.\n   *   {?boolean}  autoadjust [EXPERIMENTAL] If true, tries to adjust the\n   *                          tooltip position to be fully included in the body\n   *                          area. Doesn't work on Firefox 30. Better work on\n   *                          elements with fixed width and height.\n   *\n   * > sigma.plugins.tooltip(s, {\n   * >   node: {\n   * >     template: 'Hello node!'\n   * >   },\n   * >   edge: {\n   * >     template: 'Hello edge!'\n   * >   },\n   * >   stage: {\n   * >     template: 'Hello stage!'\n   * >   }\n   * > });\n   *\n   * @param {sigma}    s        The related sigma instance.\n   * @param {renderer} renderer The related sigma renderer.\n   * @param {object}   options  An object with options.\n   */\n  function Tooltips(s, renderer, options) {\n    var self = this,\n        so = sigma.utils.extend(options.stage, settings.stage),\n        no = sigma.utils.extend(options.node, settings.node),\n        eo = sigma.utils.extend(options.edge, settings.edge),\n        _tooltip,\n        _timeoutHandle,\n        _doubleClick = false;\n\n    sigma.classes.dispatcher.extend(this);\n\n    s.bind('kill', function() {\n      sigma.plugins.killTooltips(s);\n    });\n\n    function contextmenuListener(event) {\n      event.preventDefault();\n    }\n\n    /**\n     * This function removes the existing tooltip and creates a new tooltip for a\n     * specified node or edge.\n     *\n     * @param {object} o       The node or the edge.\n     * @param {object} options The options related to the object.\n     * @param {number} x       The X coordinate of the mouse.\n     * @param {number} y       The Y coordinate of the mouse.\n     */\n    this.open = function(o, options, x, y) {\n      remove();\n\n      // Create the DOM element:\n      _tooltip = document.createElement('div');\n      if (options.renderer) {\n        // Copy the object:\n        var clone = Object.create(null),\n            tooltipRenderer,\n            k;\n        for (k in o)\n          clone[k] = o[k];\n\n        tooltipRenderer = options.renderer.call(s.graph, clone, options.template);\n\n        if (typeof tooltipRenderer === 'string')\n           _tooltip.innerHTML = tooltipRenderer;\n        else\n            // tooltipRenderer is a dom element:\n           _tooltip.appendChild(tooltipRenderer);\n      } else {\n        _tooltip.innerHTML = options.template;\n      }\n\n      // Style it:\n      _tooltip.className = options.cssClass;\n      _tooltip.style.position = 'relative';\n\n      // container position:\n      var containerRect = renderer.container.getBoundingClientRect();\n      x = ~~(x - containerRect.left);\n      y = ~~(y - containerRect.top);\n\n      // Default position is mouse position:\n      _tooltip.style.left = x + 'px';\n      _tooltip.style.top = y + 'px';\n\n      // Execute after rendering:\n      setTimeout(function() {\n        if (!_tooltip)\n          return;\n\n        // Insert the element in the DOM:\n        renderer.container.appendChild(_tooltip);\n\n        // Find offset:\n        var bodyRect = document.body.getBoundingClientRect(),\n            tooltipRect = _tooltip.getBoundingClientRect(),\n            offsetTop =  tooltipRect.top - bodyRect.top,\n            offsetBottom = bodyRect.bottom - tooltipRect.bottom,\n            offsetLeft =  tooltipRect.left - bodyRect.left,\n            offsetRight = bodyRect.right - tooltipRect.right;\n\n        if (options.position === 'top') {\n          // New position vertically aligned and on top of the mouse:\n          _tooltip.className = options.cssClass + ' top';\n          _tooltip.style.left = x - (tooltipRect.width / 2) + 'px';\n          _tooltip.style.top = y - tooltipRect.height + 'px';\n        }\n        else if (options.position === 'bottom') {\n          // New position vertically aligned and on bottom of the mouse:\n          _tooltip.className = options.cssClass + ' bottom';\n          _tooltip.style.left = x - (tooltipRect.width / 2) + 'px';\n          _tooltip.style.top = y + 'px';\n        }\n        else if (options.position === 'left') {\n          // New position vertically aligned and on bottom of the mouse:\n          _tooltip.className = options.cssClass+ ' left';\n          _tooltip.style.left = x - tooltipRect.width + 'px';\n          _tooltip.style.top = y - (tooltipRect.height / 2) + 'px';\n        }\n        else if (options.position === 'right') {\n          // New position vertically aligned and on bottom of the mouse:\n          _tooltip.className = options.cssClass + ' right';\n          _tooltip.style.left = x + 'px';\n          _tooltip.style.top = y - (tooltipRect.height / 2) + 'px';\n        }\n\n        // Adjust position to keep the tooltip inside body:\n        // FIXME: doesn't work on Firefox\n        if (options.autoadjust) {\n\n          // Update offset\n          tooltipRect = _tooltip.getBoundingClientRect();\n          offsetTop = tooltipRect.top - bodyRect.top;\n          offsetBottom = bodyRect.bottom - tooltipRect.bottom;\n          offsetLeft = tooltipRect.left - bodyRect.left;\n          offsetRight = bodyRect.right - tooltipRect.right;\n\n          if (offsetBottom < 0) {\n            _tooltip.className = options.cssClass;\n            if (options.position === 'top' || options.position === 'bottom') {\n              _tooltip.className = options.cssClass + ' top';\n            }\n            _tooltip.style.top = y - tooltipRect.height + 'px';\n          }\n          else if (offsetTop < 0) {\n            _tooltip.className = options.cssClass;\n            if (options.position === 'top' || options.position === 'bottom') {\n              _tooltip.className = options.cssClass + ' bottom';\n            }\n            _tooltip.style.top = y + 'px';\n          }\n          if (offsetRight < 0) {\n            //! incorrect tooltipRect.width on non fixed width element.\n            _tooltip.className = options.cssClass;\n            if (options.position === 'left' || options.position === 'right') {\n              _tooltip.className = options.cssClass + ' left';\n            }\n            _tooltip.style.left = x - tooltipRect.width + 'px';\n          }\n          else if (offsetLeft < 0) {\n            _tooltip.className = options.cssClass;\n            if (options.position === 'left' || options.position === 'right') {\n              _tooltip.className = options.cssClass + ' right';\n            }\n            _tooltip.style.left = x + 'px';\n          }\n        }\n      }, 0);\n    };\n\n    /**\n     * This function removes the tooltip element from the DOM.\n     */\n    function remove() {\n      if (_tooltip && _tooltip.parentNode) {\n        // Remove from the DOM:\n        _tooltip.parentNode.removeChild(_tooltip);\n        _tooltip = null;\n      }\n    }\n\n    /**\n     * This function clears a potential timeout function related to the tooltip\n     * and removes the tooltip.\n     */\n    function cancel() {\n      clearTimeout(_timeoutHandle);\n      _timeoutHandle = false;\n      remove();\n    }\n\n    // INTERFACE:\n    this.close = function() {\n      cancel();\n      return this;\n    };\n\n    this.kill = function() {\n      this.unbindEvents();\n      _tooltip = null;\n      _timeoutHandle = null;\n      _doubleClick = false;\n    }\n\n    this.unbindEvents = function() {\n      if (options.stage) {\n        s.unbind(so.show);\n        s.unbind(so.hide);\n        if (so.show !== 'doubleClickStage') {\n          s.unbind('doubleClickStage');\n        }\n      }\n      if (options.node) {\n        s.unbind(no.show);\n        s.unbind(no.hide);\n        if (no.show !== 'doubleClickNode') {\n          s.unbind('doubleClickNode');\n        }\n      }\n      if (options.edge) {\n        s.unbind(eo.show);\n        s.unbind(eo.hide);\n        if (eo.show !== 'doubleClickEdge') {\n          s.unbind('doubleClickEdge');\n        }\n      }\n      if (no.show === 'rightClickNode' ||\n          eo.show === 'rightClickEdge') {\n        renderer.container.removeEventListener(\n          'contextmenu',\n          contextmenuListener\n        );\n      }\n    };\n\n    // STAGE tooltip:\n    if (options.stage) {\n      if (options.stage.renderer !== undefined &&\n          typeof options.stage.renderer !== 'function')\n        throw 'The render of the stage tooltip must be a function.';\n\n      if (options.stage.position !== undefined) {\n        if (options.stage.position !== 'top' &&\n            options.stage.position !== 'bottom' &&\n            options.stage.position !== 'left' &&\n            options.stage.position !== 'right') {\n          throw 'The value of options.position must be either: top, bottom, left, right.';\n        }\n      }\n\n      s.bind(so.show, function(event) {\n        if (so.show !== 'doubleClickStage' && _doubleClick) {\n          return;\n        }\n\n        var clientX = event.data.captor.clientX,\n            clientY = event.data.captor.clientY;\n\n        clearTimeout(_timeoutHandle);\n        _timeoutHandle = setTimeout(function() {\n          self.open(\n            null,\n            so,\n            clientX,\n            clientY);\n\n          self.dispatchEvent('shown');\n        }, so.delay);\n      });\n\n      s.bind(so.hide, function(event) {\n        var p = _tooltip;\n        cancel();\n        if (p)\n          self.dispatchEvent('hidden');\n      });\n\n      if (so.show !== 'doubleClickStage') {\n        s.bind('doubleClickStage', function(event) {\n          cancel();\n          _doubleClick = true;\n          self.dispatchEvent('hidden');\n          setTimeout(function() {\n            _doubleClick = false;\n          }, settings.doubleClickDelay);\n        })\n      }\n    }\n\n    // NODE tooltip:\n    if (options.node) {\n      if (options.node.renderer !== undefined &&\n          typeof options.node.renderer !== 'function')\n        throw 'The render of the node tooltip must be a function.';\n\n      if (options.node.position !== undefined) {\n        if (options.node.position !== 'top' &&\n            options.node.position !== 'bottom' &&\n            options.node.position !== 'left' &&\n            options.node.position !== 'right') {\n          throw 'The value of options.position must be either: top, bottom, left, right.';\n        }\n      }\n\n      s.bind(no.show, function(event) {\n        if (no.show !== 'doubleClickNode' && _doubleClick) {\n          return;\n        }\n\n        var n = event.data.node || event.data.nodes[0],\n            clientX = event.data.captor.clientX,\n            clientY = event.data.captor.clientY;\n\n        clearTimeout(_timeoutHandle);\n        _timeoutHandle = setTimeout(function() {\n          self.open(\n            n,\n            no,\n            clientX,\n            clientY);\n\n          self.dispatchEvent('shown');\n        }, no.delay);\n      });\n\n      s.bind(no.hide, function(event) {\n        var p = _tooltip;\n        cancel();\n        if (p)\n          self.dispatchEvent('hidden');\n      });\n\n      if (no.show !== 'doubleClickNode') {\n        s.bind('doubleClickNode', function(event) {\n          cancel();\n          _doubleClick = true;\n          self.dispatchEvent('hidden');\n          setTimeout(function() {\n            _doubleClick = false;\n          }, settings.doubleClickDelay);\n        })\n      }\n    }\n\n    // EDGE tooltip:\n    if (options.edge) {\n      if (options.edge.renderer !== undefined &&\n          typeof options.edge.renderer !== 'function')\n        throw 'The render of the edge tooltip must be a function.';\n\n      if (options.edge.position !== undefined) {\n        if (options.edge.position !== 'top' &&\n            options.edge.position !== 'bottom' &&\n            options.edge.position !== 'left' &&\n            options.edge.position !== 'right') {\n          throw 'The value of options.position must be either: top, bottom, left, right.';\n        }\n      }\n\n      s.bind(eo.show, function(event) {\n        if (eo.show !== 'doubleClickEdge' && _doubleClick) {\n          return;\n        }\n\n        var e = event.data.edge || event.data.edges[0],\n            clientX = event.data.captor.clientX,\n            clientY = event.data.captor.clientY;\n\n        clearTimeout(_timeoutHandle);\n        _timeoutHandle = setTimeout(function() {\n          self.open(\n            e,\n            eo,\n            clientX,\n            clientY);\n\n          self.dispatchEvent('shown');\n        }, eo.delay);\n      });\n\n      s.bind(eo.hide, function(event) {\n        var p = _tooltip;\n        cancel();\n        if (p)\n          self.dispatchEvent('hidden');\n      });\n\n      if (eo.show !== 'doubleClickEdge') {\n        s.bind('doubleClickEdge', function(event) {\n          cancel();\n          _doubleClick = true;\n          self.dispatchEvent('hidden');\n          setTimeout(function() {\n            _doubleClick = false;\n          }, settings.doubleClickDelay);\n        })\n      }\n    }\n\n    // Prevent the browser context menu to appear\n    // if the right click event is already handled:\n    if (no.show === 'rightClickNode' || eo.show === 'rightClickEdge') {\n      renderer.container.addEventListener(\n        'contextmenu',\n        contextmenuListener\n      );\n    }\n  }\n\n  /**\n   * Interface\n   * ------------------\n   */\n  var _instance = {};\n\n  /**\n   * @param {sigma}    s        The related sigma instance.\n   * @param {renderer} renderer The related sigma renderer.\n   * @param {object}   options  An object with options.\n   */\n  sigma.plugins.tooltips = function(s, renderer, options) {\n    // Create object if undefined\n    if (!_instance[s.id]) {\n      _instance[s.id] = new Tooltips(s, renderer, options);\n    }\n    return _instance[s.id];\n  };\n\n  /**\n   *  This function kills the tooltips instance.\n   */\n  sigma.plugins.killTooltips = function(s) {\n    if (_instance[s.id] instanceof Tooltips) {\n      _instance[s.id].kill();\n    }\n    delete _instance[s.id];\n  };\n\n}).call(window);\n","/<!--\n  Display and manage Network Information\n -->\n \n <template>\n    <div id=\"sticky\">\n        <v-toolbar  class=\"my-toolbar\">\n            <v-tooltip bottom>\n                <span>Export host configuration of local node </span>\n                <template v-slot:activator=\"{ on }\">\n                    <v-btn v-on=\"on\" v-on:click=\"saveAs('export')\" >\n                        <v-icon>cloud</v-icon>\n                    </v-btn>   \n                </template>\n            </v-tooltip>\n\n            <v-tooltip bottom>\n                <span>Export all host configuration files</span>\n                <template v-slot:activator=\"{ on }\">\n                    <v-btn v-on=\"on\" v-on:click=\"saveAs('export-all')\" >\n                        <v-icon>cloud_circle</v-icon>\n                    </v-btn>   \n                </template>\n            </v-tooltip>\n\n            <v-tooltip bottom>\n                <span>Import host configuration file(s)</span>\n                <template v-slot:activator=\"{ on }\">\n                    <v-btn v-on=\"on\" v-on:click=\"doImport()\"  >\n                        <v-icon>cloud_download</v-icon>\n                    </v-btn>   \n                </template>\n            </v-tooltip>\n\n            <v-tooltip bottom>\n                <span>Purge unreachable nodes</span>\n                <template v-slot:activator=\"{ on }\">\n                    <v-btn v-on=\"on\" v-on:click=\"purge()\"  >\n                        <v-icon>delete_outline</v-icon>\n                    </v-btn>   \n                </template>\n            </v-tooltip>\n            <v-spacer/>\n        </v-toolbar>\n        <v-alert :value=\"error.msg!=null\" :type=\"error.type\">{{error.msg}}</v-alert>\n        <v-container fluid>\n            <v-card>\n                <v-container fluid>\n                    <div ref=\"sigmaContainer\" id='sigmaContainer'/>\n                </v-container>\n            </v-card>\n        </v-container>\n    </div>\n</template>\n\n\n<script>\nimport sigma from 'sigma'\nimport WebServices from \"@/services/WebServices\"\nimport '@/plugins/sigma.plugins.tooltips.js'\nimport '@/components/MyInputDialog'\n\nexport default {\n    name: \"graph\",\n    data: () => ({\n        graph : {\n            nodes: [],\n            edges: [],\n            verbose: true\n        },\n\n        resultData : {\n            nodes: [],\n            edges: []\n        },\n\n        settings: {\n            minEdgeSize: 0.5,\n            maxEdgeSize: 2,\n            minNodeSize: 5,\n            maxNodeSize: 8,\n            enableEdgeHovering: true,\n            labelThreshold: 1,\n            defaultEdgeColor: '#917373',\n            defaultEdgeType:'line',\n            enableHovering:true,\n            edgeColor: \"default\",\n            edgeHoverColor: '#ff6347',\n            defaultEdgeHoverColor: '#ff6347',\n            edgeHoverSizeRatio: 1,\n            edgeHoverExtremities: true,\n            fixedScaling: true,\n            zoomMin: 1,\n            zoomMax: 1\n        },\n\n        tooltipSetup : {\n            node: {\n                autoadjust: true,\n                show: 'overNode',\n                hide: 'outNode',\n                renderer: null\n            },\n            edge: {\n                autoadjust: true,\n                show: 'overEdge',\n                hide: 'outEdge',\n                renderer: null\n            },  \n        },\n\n        inputDialog: {\n            visible: false\n        },\n\n        renderer : {\n            container: null,\n            type: 'canvas'\n        },\n    }),\n\n    computed: {\n        error() {\n            return this.$store.state.error\n        },\n    },\n\n    methods: {\n        // Tooltip renderer\n        tooltipRenderer(obj, v1, v2){\n            console.log(obj,v1,v2)\n            var ref = obj['ref']\n            if (ref) {\n                return this.makeTableHTML(Object.entries(ref))\n            } else {\n                return JSON.stringify(obj)\n            }\n        },\n\n        // convert \n        makeTableHTML(myArray) {\n            var result = \"<table>\";\n            for(var i=0; i<myArray.length; i++) {\n                if (myArray[i][1]!='0') {\n                    result += \"<tr>\";\n                    for(var j=0; j<myArray[i].length; j++){\n                        if (j==0){\n                            result += \"<td align='right'>\"+this.firstCharAsCaps(myArray[i][j])+\": </td>\";\n                        } else {\n                            result += \"<td>\"+myArray[i][j]+\"</td>\";\n                        }\n                    }\n                    result += \"</tr>\";\n                }\n            }\n            result += \"</table>\";\n            return result;\n        },\n\n        firstCharAsCaps(string) {\n            return (string.charAt(0).toUpperCase() + string.slice(1)).trim();\n        },   \n\n        setup() {\n            const thisCtx = this\n            WebServices.getNodes().then(result => {\n                thisCtx.resultData.nodes = result.data\n                // convert to display format\n                thisCtx.graph.nodes = thisCtx.resultData.nodes.map(n => {\n                    return {id: n.id, label: n.name, color: '#6B0700', size: 1, ref: n }\n                })\n                // allocate on cirle\n                thisCtx.graph.nodes.forEach(function(node, i, a) {\n                    node.x = Math.cos(Math.PI * 2 * i / a.length);\n                    node.y = Math.sin(Math.PI * 2 * i / a.length);\n                });         \n                \n                WebServices.getEdges().then(result => {\n                    thisCtx.resultData.edges = result.data\n                    // convert to display format\n                    thisCtx.graph.edges = thisCtx.resultData.edges.map(n => {\n                        return {id: 'id'+n.from+'-'+n.to, source: n.from, target: n.to }\n                    })\n\n                    thisCtx.renderGraph()\n                },error => {\n                    this.$store.dispatch('setError', error)\n                })\n\n            },error => {\n                this.$store.dispatch('setError', error)\n            })\n        },\n\n        renderGraph() {\n            // define container\n            this.renderer.container = this.$refs.sigmaContainer\n\n            // setup sigma\n            var s = new sigma({ renderer: this.renderer, settings: this.settings})\n\n            // setup tooltips\n            this.tooltipSetup.node.renderer = this.tooltipRenderer\n            this.tooltipSetup.edge.renderer = this.tooltipRenderer\n            sigma.plugins.tooltips(s, s.renderers[0],this.tooltipSetup);\n\n            s.graph.read(this.graph);\n            s.refresh();\n        },\n\n        // execute post action\n        action(action) {\n            this.$store.dispatch(\"setError\", null)\n            var self = this\n            WebServices.action(action).then( result => {\n                console.log(result); \n            }, err => {\n                self.$store.dispatch('setError', err)\n            });\n        },\n\n        // export and display save as dialog\n        saveAs(action){\n            this.$store.dispatch(\"setError\", null)\n            var self = this\n            WebServices.getDownloadLink(action).then(url => {\n                var link = document.getElementById(\"documentContent\")\n                if (link == null) {\n                    link = document.createElement('a');\n                    link.setAttribute(\"id\", \"documentContent\");\n                }\n                link.setAttribute('Download', action+'.txt' );\n                link.href = url;\n                document.body.appendChild(link);\n                link.click();\n             }).catch((error) => {\n                self.$store.dispatch('setError', error)\n            })\n        },\n\n        // import a selected file\n        doImport() {\n            var self = this\n            var input = document.createElement('input');\n            input.type = 'file';\n            input.onchange = e => { \n                var file = e.target.files[0]; \n                WebServices.doImport(file).then(response => {\n                    self.$store.dispatch('setError', {type:'success', msg: response.data})\n                    console.log(response)\n                }).catch((error) => {\n                    self.$store.dispatch('setError', error.response.data)\n                })           \n            }\n            input.click();\n        },\n\n        // purge unreachable nodes\n        purge() {\n            this.action('purge')\n            // reload data\n            this.setup()\n        }\n\n    },\n\n    mounted() {\n        this.setup()\n    }\n}\n\n</script>\n\n<style>\n    #sticky {\n        top: 63px;\n        height: 63px;\n        z-index: 1;\n        position: -webkit-sticky;\n        position: sticky;\n        visibility: visible;\n    }\n\n    .myToolbar > .v-toolbar__content {\n        height: 63px\n    }\n\n    #sigmaContainer {\n        height:70vh;\n    }\n\n    .sigma-tooltip {\n        max-width: 240px;\n        max-height: 280px;\n        background-color: lightyellow;\n        border: 1px solid ;\n        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);\n        border-radius: 12px;\n        cursor: auto;\n        font-family: Arial;\n        font-size: 9px;\n        color: black;\n        font-weight: normal;\n        padding-left: 20px;\n        padding-right: 20px;\n    }\n\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Network.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Network.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Network.vue?vue&type=template&id=014a28d2&\"\nimport script from \"./Network.vue?vue&type=script&lang=js&\"\nexport * from \"./Network.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Network.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!/Users/pschatzmann/go/src/github.com/pschatzmann/tincwebgui/gui/node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VAlert } from 'vuetify/lib'\nimport { VBtn } from 'vuetify/lib'\nimport { VCard } from 'vuetify/lib'\nimport { VContainer } from 'vuetify/lib'\nimport { VIcon } from 'vuetify/lib'\nimport { VSpacer } from 'vuetify/lib'\nimport { VToolbar } from 'vuetify/lib'\nimport { VTooltip } from 'vuetify/lib'\ninstallComponents(component, {VAlert,VBtn,VCard,VContainer,VIcon,VSpacer,VToolbar,VTooltip})\n","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n",";(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grapĥ with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _self = this,\n        _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'overNode',\n        'overNodes',\n        'outNode',\n        'outNodes',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n    // Deal with resize:\n    window.addEventListener('resize', function() {\n      if (_self.settings)\n        _self.refresh();\n    });\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'overNode',\n          'overNodes',\n          'overEdge',\n          'overEdges',\n          'outNode',\n          'outNodes',\n          'outEdge',\n          'outEdges',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          c.settings('enableEdgeHovering')\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var i,\n        l,\n        a,\n        prefix = 0;\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[a[i]].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[a[i]].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"' +\n                    a[i].id +\n                    '\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.2.1';\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n\n/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n\n// Hardcoded export for the node.js version:\nvar sigma = this.sigma,\n    conrad = this.conrad;\n\nsigma.conrad = conrad;\n\n// Dirty polyfills to permit sigma usage in node\nif (typeof HTMLElement === 'undefined')\n  HTMLElement = function() {};\n\nif (typeof window === 'undefined')\n  window = {\n    addEventListener: function() {}\n  };\n\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports)\n    exports = module.exports = sigma;\n  exports.sigma = sigma;\n}\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return (nCrossProduct < epsilon &&\n     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&\n     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n\n\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  /**\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n   * requestAnimationFrame polyfill by Erik Möller.\n   * fixes from Paul Irish and Tino Zijdel\n   * MIT license\n   */\n  var x,\n      lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {\n    global.requestAnimationFrame =\n      global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame =\n      global[vendors[x] + 'CancelAnimationFrame'] ||\n      global[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!global.requestAnimationFrame)\n    global.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = global.setTimeout(\n            function() {\n              callback(currTime + timeToCall);\n            },\n            timeToCall\n          );\n\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n  if (!global.cancelAnimationFrame)\n    global.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n\n  /**\n   * Function.prototype.bind polyfill found on MDN.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\n   * Public domain\n   */\n  if (!Function.prototype.bind)\n    Function.prototype.bind = function(oThis) {\n      if (typeof this !== 'function')\n        // Closest thing possible to the ECMAScript 5 internal IsCallable\n        // function:\n        throw new TypeError(\n          'Function.prototype.bind - what is trying to be bound is not callable'\n        );\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP,\n          fBound;\n\n      fNOP = function() {};\n      fBound = function() {\n        return fToBind.apply(\n          this instanceof fNOP && oThis ?\n            this :\n            oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments))\n        );\n      };\n\n      fNOP.prototype = this.prototype;\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n})(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    this.dispatcher = dispatcher;\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    this.configurable = configurable;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex[node.id])\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0;\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode;\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex[edge.source])\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex[edge.target])\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex[edge.id])\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])\n      this.inNeighborsIndex[validEdge.target][validEdge.source] =\n        Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n      validEdge;\n\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])\n      this.outNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])\n      this.allNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])\n        this.allNeighborsIndex[validEdge.target][validEdge.source] =\n          Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n        validEdge;\n    }\n\n    // Keep counts up to date:\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex[id])\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    delete this.nodesIndex[id];\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex[id])\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)\n      delete this.inNeighborsIndex[edge.target][edge.source];\n\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)\n      delete this.outNeighborsIndex[edge.source][edge.target];\n\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)\n      delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)\n        delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.edgesIndex);\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.inNeighborsIndex);\n    __emptyObject(this.outNeighborsIndex);\n    __emptyObject(this.allNeighborsIndex);\n    __emptyObject(this.inNeighborsCount);\n    __emptyObject(this.outNeighborsCount);\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex[v];\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex[v[i]]);\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which[v];\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which[v[i]]);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex[v];\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex[v[i]]);\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    this.graph = graph;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n  var quad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(nodes, params) {\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '';\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    // Inserting graph nodes into the tree\n    for (var i = 0, l = nodes.length; i < l; i++) {\n\n      // Inserting node\n      _quadInsert(\n        nodes[i],\n        _geom.pointToSquare({\n          x: nodes[i][prefix + 'x'],\n          y: nodes[i][prefix + 'y'],\n          size: nodes[i][prefix + 'size']\n        }),\n        this._tree\n      );\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var nodes = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var nodesArray = [];\n    for (var i in nodes)\n      nodesArray.push(nodes[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n\n    return nodesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    this.quad = quad;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: Sébastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n  var edgequad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  edgequad.prototype.index = function(graph, params) {\n    if (!this._enabled)\n      return this._tree;\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.edgequad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    var edges = graph.edges();\n\n    // Inserting graph edges into the tree\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      };\n\n      // Inserting edge\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n          _quadInsert(\n            edges[i],\n            _geom.selfLoopToSquare(n),\n            this._tree);\n        }\n        else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n          _quadInsert(\n            edges[i],\n            _geom.quadraticCurveToSquare(e, cp),\n            this._tree);\n        }\n      }\n      else {\n        _quadInsert(\n          edges[i],\n          _geom.lineToSquare(e),\n          this._tree);\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving edges\n    var edges = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var edgesArray = [];\n    for (var i in edges)\n      edgesArray.push(edges[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n\n    return edgesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else\n    this.edgequad = edgequad;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n\n\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if (\n          (index[o.source] || index[o.target]) &&\n          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n        )\n          this.edgesOnScreen.push(o);\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          renderers = sigma.canvas.edges;\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[\n              o.type || this.settings(options, 'defaultEdgeType')\n            ] || renderers.def)(\n              o,\n              graph.nodes(o.source),\n              graph.nodes(o.target),\n              this.contexts.edges,\n              embedSettings\n            );\n          }\n\n          // Draw edge labels:\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden)\n                (renderers[\n                  o.type || this.settings(options, 'defaultEdgeType')\n                ] || renderers.def)(\n                  o,\n                  graph.nodes(o.source),\n                  graph.nodes(o.target),\n                  this.contexts.labels,\n                  embedSettings\n                );\n            }\n          }\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[\n            o.type || this.settings(options, 'defaultEdgeType')\n          ] || renderers.def)(\n            o,\n            graph.nodes(o.source),\n            graph.nodes(o.target),\n            this.contexts.edges,\n            embedSettings\n          );\n        }\n\n        // Draw edge labels:\n        // - No batching\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)\n            if (!a[i].hidden)\n              (renderers[\n                a[i].type || this.settings(options, 'defaultEdgeType')\n              ] || renderers.def)(\n                a[i],\n                graph.nodes(a[i].source),\n                graph.nodes(a[i].target),\n                this.contexts.labels,\n                embedSettings\n              );\n        }\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.nodes,\n            embedSettings\n          );\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.labels,\n            embedSettings\n          );\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          e = (subrenderers[a[i].type] || subrenderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.labels[a[i].id] = e;\n          this.domElements.groups.labels.appendChild(e);\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        (subrenderers[a[i].type] || subrenderers.def).update(\n          a[i],\n          this.domElements.labels[a[i].id],\n          embedSettings\n        );\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      var hover = (renderers[node.type] || renderers.def).create(\n        node,\n        self.domElements.nodes[node.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[node.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      // Deleting element\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[node.id]\n      );\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id];\n\n      // Reinstate\n      self.domElements.groups.nodes.appendChild(\n        self.domElements.nodes[node.id]\n      );\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', (w * pixelRatio));\n        this.domElements.graph.setAttribute('height', (h * pixelRatio));\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Check if WebGL is enabled:\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n  if (webgl) {\n    canvas = document.createElement('canvas');\n    try {\n      webgl = !!(\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl')\n      );\n    } catch (e) {\n      webgl = false;\n    }\n  }\n\n  // Copy the good renderer:\n  sigma.renderers.def = webgl ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.labels.def = function(node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n\n    if (size < settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +\n      fontSize + 'px ' + settings('font');\n    context.fillStyle = (settings('labelColor') === 'node') ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultLabelColor');\n\n    context.fillText(\n      node.label,\n      Math.round(node[prefix + 'x'] + size + 3),\n      Math.round(node[prefix + 'y'] + fontSize / 3)\n    );\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(\n        context.measureText(node.label).width + fontSize / 2 + size + 7\n      );\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    // Node border:\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + settings('borderSize'),\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n\n      context.fillText(\n        node.label,\n        Math.round(node[prefix + 'x'] + size + 3),\n        Math.round(node[prefix + 'y'] + fontSize / 3)\n      );\n    }\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      // Control point\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +\n        (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +\n        (source[prefix + 'x'] - target[prefix + 'x']) / 4;\n\n      // Path\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +\n              'Q' + cx + ',' + cy + ' ' +\n              target[prefix + 'x'] + ',' + target[prefix + 'y'];\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n    margin =\n      (\n        settings('rescaleIgnoreSize') ?\n          0 :\n          (settings('maxNodeSize') || sizeMax) / scale\n      ) +\n      (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin;\n\n    // Fix the scaling with the new extrema:\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] =\n        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] =\n        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              Math.pow(modifiedX - x, 2) +\n              Math.pow(modifiedY - y, 2)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y']);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes)\n          outNodes.push(overNodes[k]);\n\n        overNodes = {};\n        // Dispatch both single and multi events:\n        for (i = 0, l = outNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        if (outNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: outNodes,\n            captor: e.data\n          });\n\n        overEdges = {};\n        // Dispatch both single and multi events:\n        for (i = 0, le = outEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        if (outEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: outEdges,\n            captor: e.data\n          });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length;\n\n        // Check newly overred nodes:\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, l = newOverNodes.length; i < l; i++)\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        for (i = 0, l = newOutNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        if (newOverNodes.length)\n          self.dispatchEvent('overNodes', {\n            nodes: newOverNodes,\n            captor: e.data\n          });\n        if (newOutNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: newOutNodes,\n            captor: e.data\n          });\n\n        // Check newly overred edges:\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, le = newOverEdges.length; i < le; i++)\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        for (i = 0, le = newOutEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        if (newOverEdges.length)\n          self.dispatchEvent('overEdges', {\n            edges: newOverEdges,\n            captor: e.data\n          });\n        if (newOutEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: newOutEdges,\n            captor: e.data\n          });\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph;\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n\n    this.bind('overNode', function(event) {\n      var node = event.data.node;\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n\n    this.bind('outNode', function(event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n\n    this.bind('overEdge', function(event) {\n      var edge = event.data.edge;\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n\n    this.bind('outEdge', function(event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Clear self.contexts.hover:\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render: single hover\n      if (\n        embedSettings('enableHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredNodes).length\n      ) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (\n          nodeRenderers[hoveredNode.type] ||\n          nodeRenderers[defaultNodeType] ||\n          nodeRenderers.def\n        )(\n          hoveredNode,\n          self.contexts.hover,\n          embedSettings\n        );\n      }\n\n      // Node render: multiple hover\n      if (\n        embedSettings('enableHovering') &&\n        !embedSettings('singleHover')\n      )\n        for (k in hoveredNodes)\n          (\n            nodeRenderers[hoveredNodes[k].type] ||\n            nodeRenderers[defaultNodeType] ||\n            nodeRenderers.def\n          )(\n            hoveredNodes[k],\n            self.contexts.hover,\n            embedSettings\n          );\n\n      // Edge render: single hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredEdges).length\n      ) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (! hoveredEdge.hidden) {\n          (\n            edgeRenderers[hoveredEdge.type] ||\n            edgeRenderers[defaultEdgeType] ||\n            edgeRenderers.def\n          ) (\n            hoveredEdge,\n            source,\n            target,\n            self.contexts.hover,\n            embedSettings\n          );\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (\n              extremitiesRenderers[hoveredEdge.type] ||\n              extremitiesRenderers.def\n            )(\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n          } else {\n            // Avoid edges rendered over nodes:\n            (\n              sigma.canvas.nodes[source.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              source,\n              self.contexts.hover,\n              embedSettings\n            );\n            (\n              sigma.canvas.nodes[target.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n          }\n        }\n      }\n\n      // Edge render: multiple hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        !embedSettings('singleHover')\n      ) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (\n              edgeRenderers[hoveredEdge.type] ||\n              edgeRenderers[defaultEdgeType] ||\n              edgeRenderers.def\n            ) (\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (\n                extremitiesRenderers[hoveredEdge.type] ||\n                extremitiesRenderers.def\n              )(\n                hoveredEdge,\n                source,\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            } else {\n              // Avoid edges rendered over nodes:\n              (\n                sigma.canvas.nodes[source.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                source,\n                self.contexts.hover,\n                embedSettings\n              );\n              (\n                sigma.canvas.nodes[target.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);\n","module.exports = require(\"core-js/library/fn/json/stringify\");"],"sourceRoot":""}